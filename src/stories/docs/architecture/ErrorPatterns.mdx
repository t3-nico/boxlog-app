import { Meta } from '@storybook/addon-docs/blocks';

<Meta title="Docs/アーキテクチャ/エラーパターン" />

# エラーパターン辞書

BoxLogの統一エラー管理システム。エラーコード体系、自動復旧、ユーザー通知、Sentry連携を提供する。

---

## エラーコード体系（7カテゴリ）

| カテゴリ | コード範囲 | 例 |
|---------|-----------|-----|
| **AUTH** | 1xxx | `INVALID_TOKEN`(1001), `EXPIRED_TOKEN`(1002), `NO_PERMISSION`(1003) |
| **VALIDATION** | 2xxx | `REQUIRED_FIELD`(2001), `INVALID_FORMAT`(2002), `INVALID_EMAIL`(2004) |
| **DB** | 3xxx | `CONNECTION_FAILED`(3001), `QUERY_TIMEOUT`(3002), `NOT_FOUND`(3004) |
| **BIZ** | 4xxx | ビジネスロジックエラー |
| **EXTERNAL** | 5xxx | 外部サービス連携エラー |
| **SYSTEM** | 6xxx | システム・インフラエラー |
| **RATE** | 7xxx | レート制限エラー |

---

## 基本的な使い方

### エラーの作成と処理

```typescript
import { createAppError, ERROR_CODES } from '@/config/error-patterns';
import { handleError } from '@/lib/error-handler';

const error = createAppError('ユーザーが見つかりません', ERROR_CODES.NOT_FOUND, {
  source: 'user-service',
  userId: 'user-123',
  context: { searchId: 'invalid-id' },
});

await handleError(error);
```

### React Hookでの使用

```typescript
import { useErrorHandler } from '@/hooks/use-error-handler';

function UserProfile() {
  const { handleWithRecovery, errorState, clearError } = useErrorHandler();

  const loadUser = async () => {
    const result = await handleWithRecovery(
      () => fetch('/api/user/123').then((res) => res.json()),
      ERROR_CODES.API_UNAVAILABLE,
      { context: { component: 'UserProfile' } },
    );

    if (result.success) {
      setUser(result.data);
    }
  };

  return (
    <div>
      {errorState.hasError && (
        <ErrorNotification error={errorState.error} onDismiss={clearError} />
      )}
      <button onClick={loadUser}>ユーザーを読み込み</button>
    </div>
  );
}
```

---

## 自動復旧戦略

### カテゴリ別リトライ設定

| カテゴリ | リトライ | 戦略 |
|---------|---------|------|
| AUTH | 無効 | 認証エラーはリトライしない |
| DB | 有効（3回） | 指数バックオフ + ジッター |
| EXTERNAL | 有効（3回） | 指数バックオフ |
| RATE | 有効 | Retry-After ヘッダーに従う |

### サーキットブレーカー

```typescript
{
  enabled: true,
  failureThreshold: 5,      // 5回失敗でOPEN
  recoveryTimeout: 30000,   // 30秒後に HALF_OPEN
  successThreshold: 3       // 3回成功で CLOSED
}
```

---

## ベストプラクティス

### エラーコードの選択

```typescript
// ✅ 具体的なエラーコード
throw createAppError('Email format is invalid', ERROR_CODES.INVALID_EMAIL);

// ❌ 汎用的すぎるエラーコード
throw createAppError('Email format is invalid', ERROR_CODES.INVALID_FORMAT);
```

### コンテキスト情報

```typescript
// ✅ 有用なコンテキスト（デバッグに必要な情報のみ）
const error = createAppError('User not found', ERROR_CODES.NOT_FOUND, {
  source: 'user-service',
  userId: requestedUserId,
  context: { searchCriteria: 'email' },
});

// ❌ 機密情報を含めない
const error = createAppError('Login failed', ERROR_CODES.INVALID_CREDENTIALS, {
  context: { password: 'user-password' }, // ❌ 絶対禁止
});
```

### ユーザー向けメッセージ

```typescript
// ユーザー向けメッセージはエラーパターンから自動選択される
const error = createAppError(
  'Database connection timeout', // 技術的詳細（ログ用）
  ERROR_CODES.QUERY_TIMEOUT,
);
// → ユーザーには「処理がタイムアウトしました」と表示される
```

---

## Sentry連携

エラーは自動的にSentryに送信され、以下で分類される:

| 分類 | 内容 |
|------|------|
| **タグ** | errorCode, errorCategory, severity, domain, team |
| **コンテキスト** | errorPattern, errorMetadata |
| **フィンガープリント** | 自動グルーピング |

```typescript
import { reportToSentry } from '@/lib/sentry';
import { AppError } from '@/config/error-patterns';

const appError = new AppError('操作に失敗', 'SYSTEM_ERROR_500', { context: 'example' });
reportToSentry(appError);
```

---

## マイグレーション（従来 → エラーパターン）

```typescript
// ❌ Before: 手動エラー処理
try {
  const user = await fetchUser(id);
} catch (error) {
  console.error('Error fetching user:', error);
  toast.error('ユーザーの取得に失敗しました');
}

// ✅ After: エラーパターン辞書
try {
  const user = await fetchUser(id);
} catch (error) {
  await handleError(error, ERROR_CODES.API_UNAVAILABLE, {
    source: 'user-fetch',
    context: { userId: id },
  });
}
```

---

## 関連Story

- [Patterns/ErrorPages](?path=/docs/patterns-errorpages--docs) — エラーページのUIパターン
- [Patterns/Feedback](?path=/docs/patterns-feedback--docs) — toast通知パターン

---

**最終更新**: 2026-02-12 | **バージョン**: v1.0
