'use client'

import React, { useState, useCallback, useRef } from 'react'
import { HOUR_HEIGHT } from '../../shared/constants/grid.constants'
import { useToast } from '@/components/shadcn-ui/toast'
import { calendarColors } from '@/features/calendar/theme'

export interface DragState {
  isDragging: boolean
  isResizing: boolean
  draggedEventId: string | null
  dragStartPosition: { x: number; y: number } | null
  currentPosition: { x: number; y: number } | null
  originalPosition: { top: number; left: number; width: number; height: number } | null
  snappedPosition: { top: number; height?: number } | null
  previewTime: { start: Date; end: Date } | null
  recentlyDragged: boolean // „Éâ„É©„ÉÉ„Ç∞ÁµÇ‰∫ÜÁõ¥Âæå„ÅÆ„ÇØ„É™„ÉÉ„ÇØÈò≤Ê≠¢Áî®
  recentlyResized: boolean // „É™„Çµ„Ç§„Ç∫ÁµÇ‰∫ÜÁõ¥Âæå„ÅÆ„ÇØ„É™„ÉÉ„ÇØÈò≤Ê≠¢Áî®Ôºà„Çà„ÇäÂé≥Ê†ºÔºâ
  ghostElement: HTMLElement | null // „Ç¥„Éº„Çπ„ÉàË¶ÅÁ¥†
}

export interface DragHandlers {
  handleMouseDown: (eventId: string, e: React.MouseEvent, originalPosition: { top: number; left: number; width: number; height: number }) => void
  handleMouseMove: (e: MouseEvent) => void
  handleMouseUp: () => void
  handleEventDrop: (eventId: string, newStartTime: Date) => void
  handleResizeStart: (eventId: string, direction: 'top' | 'bottom', e: React.MouseEvent, originalPosition: { top: number; left: number; width: number; height: number }) => void
}

interface UseDragAndDropProps {
  onEventUpdate?: (eventId: string, updates: { startTime: Date; endTime: Date }) => Promise<void> | void
  date: Date
  events: any[] // „Ç§„Éô„É≥„Éà„Éá„Éº„Çø„ÇíÂèó„ÅëÂèñ„Çã
}

export function useDragAndDrop({ onEventUpdate, date, events }: UseDragAndDropProps) {
  const { success } = useToast()
  const [dragState, setDragState] = useState<DragState>({
    isDragging: false,
    isResizing: false,
    draggedEventId: null,
    dragStartPosition: null,
    currentPosition: null,
    originalPosition: null,
    snappedPosition: null,
    previewTime: null,
    recentlyDragged: false,
    recentlyResized: false,
    ghostElement: null
  })

  const dragDataRef = useRef<{
    eventId: string
    startY: number
    originalTop: number
    eventDuration: number
    hasMoved: boolean // „Éû„Ç¶„Çπ„ÅåÂÆüÈöõ„Å´ÁßªÂãï„Åó„Åü„Åã„ÅÆÂà§ÂÆö
    originalElement: HTMLElement | null // ÂÖÉ„ÅÆË¶ÅÁ¥†„Å∏„ÅÆÂèÇÁÖß
  } | null>(null)

  // „Ç¥„Éº„Çπ„ÉàË¶ÅÁ¥†‰ΩúÊàê
  const createGhostElement = useCallback((originalElement: HTMLElement, originalPosition: { top: number; left: number; width: number; height: number }) => {
    const ghost = originalElement.cloneNode(true) as HTMLElement
    
    // ÂÖÉ„ÅÆ„ÇØ„É©„Çπ„Çí„ÇØ„É™„Ç¢„Åó„Å¶„ÄÅscheduled„ÅÆactive„Ç´„É©„Éº„ÇíÈÅ©Áî®
    ghost.className = ''
    ghost.classList.add('rounded-md', 'shadow-sm', 'px-2', 'py-1', 'overflow-hidden')
    
    // scheduled„ÅÆactive„Ç´„É©„Éº„ÇíÈÅ©Áî®Ôºàcolors.ts„Åã„ÇâÂèÇÁÖßÔºâ
    const activeColorClasses = calendarColors.event.scheduled.active?.split(' ') || []
    activeColorClasses.forEach(cls => {
      if (cls) ghost.classList.add(cls)
    })
    
    // „Ç¥„Éº„Çπ„Éà„ÅÆ„Çπ„Çø„Ç§„É´Ë®≠ÂÆöÔºàÂÖÉ„ÅÆ‰ΩçÁΩÆ„Å´Âõ∫ÂÆöÔºâ
    ghost.style.position = 'absolute'
    ghost.style.top = `${originalPosition.top}px`
    ghost.style.left = `${originalPosition.left}%`
    ghost.style.width = `${originalPosition.width}%`
    ghost.style.height = `${originalPosition.height}px`
    ghost.style.opacity = '0.6'
    ghost.style.pointerEvents = 'none'
    ghost.style.zIndex = '500' // „Éâ„É©„ÉÉ„Ç∞Ë¶ÅÁ¥†„Çà„Çä‰Ωé„ÅÑ
    ghost.style.transition = 'none'
    ghost.classList.add('event-ghost')
    
    return ghost
  }, [])

  // „Éâ„É©„ÉÉ„Ç∞ÈñãÂßã
  const handleMouseDown = useCallback((
    eventId: string, 
    e: React.MouseEvent, 
    originalPosition: { top: number; left: number; width: number; height: number }
  ) => {
    // Â∑¶„ÇØ„É™„ÉÉ„ÇØ‰ª•Â§ñ„ÅØÁÑ°Ë¶ñ
    if (e.button !== 0) return
    
    e.preventDefault()
    e.stopPropagation()

    const startPosition = { x: e.clientX, y: e.clientY }
    
    // ÂÖÉ„ÅÆ„Ç§„Éô„É≥„ÉàË¶ÅÁ¥†„ÇíÂèñÂæó
    const originalElement = (e.target as HTMLElement).closest('[data-event-block="true"]') as HTMLElement
    
    // „Ç¥„Éº„Çπ„ÉàË¶ÅÁ¥†‰ΩúÊàê
    let ghostElement: HTMLElement | null = null
    if (originalElement) {
      ghostElement = createGhostElement(originalElement, originalPosition)
      
      // „Ç´„É¨„É≥„ÉÄ„Éº„Ç∞„É™„ÉÉ„Éâ„ÅÆË¶™Ë¶ÅÁ¥†„Å´„Ç¥„Éº„Çπ„Éà„ÇíÊåøÂÖ•
      const calendarGrid = originalElement.closest('[data-calendar-grid]') || originalElement.closest('.absolute.inset-0')
      if (calendarGrid) {
        const eventArea = calendarGrid.querySelector('.absolute.inset-0:last-child')
        if (eventArea) {
          eventArea.appendChild(ghostElement)
        }
      }
    }
    
    // „Éâ„É©„ÉÉ„Ç∞„Éá„Éº„Çø„ÇíË®≠ÂÆö
    dragDataRef.current = {
      eventId,
      startY: e.clientY,
      originalTop: originalPosition.top,
      eventDuration: originalPosition.height,
      hasMoved: false,
      originalElement
    }

    setDragState({
      isDragging: true,
      draggedEventId: eventId,
      dragStartPosition: startPosition,
      currentPosition: startPosition,
      originalPosition,
      snappedPosition: { top: originalPosition.top },
      previewTime: null,
      recentlyDragged: false,
      ghostElement
    })
  }, [createGhostElement])

  // 15ÂàÜÂçò‰Ωç„Åß„Çπ„Éä„ÉÉ„Éó„Åô„ÇãÈñ¢Êï∞
  const snapToQuarterHour = useCallback((yPosition: number): { snappedTop: number; hour: number; minute: number } => {
    const hourDecimal = yPosition / HOUR_HEIGHT
    const hour = Math.floor(Math.max(0, Math.min(23, hourDecimal)))
    const minuteDecimal = (hourDecimal - hour) * 60
    const minute = Math.round(minuteDecimal / 15) * 15 // 15ÂàÜÂçò‰Ωç„Å´„Çπ„Éä„ÉÉ„Éó
    
    const snappedTop = (hour + minute / 60) * HOUR_HEIGHT
    
    return { snappedTop, hour, minute: Math.min(minute, 59) }
  }, [])

  // „Éû„Ç¶„ÇπÁßªÂãïÂá¶ÁêÜ
  const handleMouseMove = useCallback((e: MouseEvent) => {
    if ((!dragState.isDragging && !dragState.isResizing) || !dragDataRef.current) return

    const dragData = dragDataRef.current
    const deltaY = e.clientY - dragData.startY
    
    // 5px‰ª•‰∏äÁßªÂãï„Åó„ÅüÂ†¥Âêà„ÅÆ„Åø„Éâ„É©„ÉÉ„Ç∞/„É™„Çµ„Ç§„Ç∫„Å®Âà§ÂÆö
    if (Math.abs(deltaY) > 5) {
      dragData.hasMoved = true
    }
    
    if (dragState.isResizing) {
      // „É™„Çµ„Ç§„Ç∫Âá¶ÁêÜ
      const newHeight = Math.max(15, dragData.eventDuration + deltaY) // ÊúÄÂ∞è15px
      const { snappedTop: snappedHeight } = snapToQuarterHour(newHeight)
      const finalHeight = Math.max(HOUR_HEIGHT / 4, snappedHeight) // ÊúÄÂ∞è15ÂàÜ
      
      // „É™„Çµ„Ç§„Ç∫‰∏≠„ÅÆ„Éó„É¨„Éì„É•„ÉºÊôÇÈñì„ÇíË®àÁÆó
      const event = events.find(e => e.id === dragData.eventId)
      let previewTime = null
      
      if (event?.startDate) {
        const newDurationMs = (finalHeight / HOUR_HEIGHT) * 60 * 60 * 1000
        const previewEndTime = new Date(event.startDate.getTime() + newDurationMs)
        previewTime = { start: event.startDate, end: previewEndTime }
      }
      
      setDragState(prev => ({
        ...prev,
        currentPosition: { x: e.clientX, y: e.clientY },
        snappedPosition: { 
          top: dragData.originalTop, 
          height: finalHeight
        },
        previewTime
      }))
    } else if (dragState.isDragging) {
      // „Éâ„É©„ÉÉ„Ç∞Âá¶ÁêÜ
      const newTop = dragData.originalTop + deltaY
      const { snappedTop, hour, minute } = snapToQuarterHour(newTop)
      
      // „Éó„É¨„Éì„É•„ÉºÊôÇÈñì„ÇíË®àÁÆó
      const event = events.find(e => e.id === dragData.eventId)
      let durationMs = 60 * 60 * 1000 // „Éá„Éï„Ç©„É´„Éà1ÊôÇÈñì
      
      if (event?.startDate && event?.endDate) {
        durationMs = event.endDate.getTime() - event.startDate.getTime()
      } else if (dragData.eventDuration) {
        durationMs = (dragData.eventDuration / HOUR_HEIGHT) * 60 * 60 * 1000
      }
      
      const previewStartTime = new Date(date)
      previewStartTime.setHours(hour, minute, 0, 0)
      const previewEndTime = new Date(previewStartTime.getTime() + durationMs)
      
      const currentPosition = { x: e.clientX, y: e.clientY }
      
      setDragState(prev => ({
        ...prev,
        currentPosition,
        snappedPosition: { top: snappedTop },
        previewTime: { start: previewStartTime, end: previewEndTime }
      }))
    }
  }, [dragState.isDragging, dragState.isResizing, snapToQuarterHour, events, date])

  // „Éâ„É©„ÉÉ„Ç∞ÁµÇ‰∫Ü
  const handleMouseUp = useCallback(() => {
    // „Ç¥„Éº„Çπ„ÉàË¶ÅÁ¥†„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
    if (dragState.ghostElement && dragState.ghostElement.parentElement) {
      dragState.ghostElement.parentElement.removeChild(dragState.ghostElement)
    }

    if ((!dragState.isDragging && !dragState.isResizing) || !dragDataRef.current || !dragState.currentPosition || !dragState.dragStartPosition) {
      setDragState({
        isDragging: false,
        isResizing: false,
        draggedEventId: null,
        dragStartPosition: null,
        currentPosition: null,
        originalPosition: null,
        snappedPosition: null,
        previewTime: null,
        recentlyDragged: false,
        recentlyResized: false,
        ghostElement: null
      })
      dragDataRef.current = null
      return
    }

    if (dragState.isResizing) {
      // „É™„Çµ„Ç§„Ç∫ÁµÇ‰∫ÜÂá¶ÁêÜ
      console.log('üü° „É™„Çµ„Ç§„Ç∫ÁµÇ‰∫Ü:', { 
        eventId: dragDataRef.current.eventId,
        newHeight: dragState.snappedPosition?.height
      })
      
      // ÂÆüÈöõ„Å´„É™„Çµ„Ç§„Ç∫„ÅåÁô∫Áîü„Åó„ÅüÂ†¥Âêà„ÅÆ„ÅøÊõ¥Êñ∞
      if (onEventUpdate && dragDataRef.current.hasMoved && dragState.snappedPosition?.height) {
        const event = events.find(e => e.id === dragDataRef.current.eventId)
        if (event?.startDate) {
          const newDurationMs = (dragState.snappedPosition.height / HOUR_HEIGHT) * 60 * 60 * 1000
          const newEndTime = new Date(event.startDate.getTime() + newDurationMs)
          
          onEventUpdate(dragDataRef.current.eventId, { 
            startTime: event.startDate, 
            endTime: newEndTime 
          })
        }
      }
      
      // „É™„Çµ„Ç§„Ç∫„ÅåÂÆüÈöõ„Å´Áô∫Áîü„Åó„Åü„Åã„ÇíË®òÈå≤
      const actuallyResized = dragDataRef.current.hasMoved
      
      // „É™„Çµ„Ç§„Ç∫Áä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
      setDragState({
        isDragging: false,
        isResizing: false,
        draggedEventId: null,
        dragStartPosition: null,
        currentPosition: null,
        originalPosition: null,
        snappedPosition: null,
        previewTime: null,
        recentlyDragged: actuallyResized, // ÂÆüÈöõ„Å´„É™„Çµ„Ç§„Ç∫„Åó„ÅüÂ†¥Âêà„ÅÆ„Åø„ÇØ„É™„ÉÉ„ÇØÁÑ°ÂäπÂåñ
        recentlyResized: actuallyResized, // „É™„Çµ„Ç§„Ç∫Â∞ÇÁî®„Éï„É©„Ç∞Ôºà„Çà„ÇäÂé≥Ê†ºÔºâ
        ghostElement: null
      })
      
      dragDataRef.current = null
      
      // ÂÆüÈöõ„Å´„É™„Çµ„Ç§„Ç∫„ÅåÁô∫Áîü„Åó„ÅüÂ†¥Âêà„ÅÆ„Åø„ÄÅ1000msÂæå„Å´„Éï„É©„Ç∞„ÇíËß£Èô§Ôºà„É™„Çµ„Ç§„Ç∫„ÅØÈï∑„ÅÑÁÑ°ÂäπÂåñ„ÅåÂøÖË¶ÅÔºâ
      if (actuallyResized) {
        setTimeout(() => {
          setDragState(prev => ({ ...prev, recentlyDragged: false, recentlyResized: false }))
        }, 1000)
      }
      
      return
    }

    const deltaY = dragState.currentPosition.y - dragState.dragStartPosition.y
    const newTop = dragDataRef.current.originalTop + deltaY

    // Êñ∞„Åó„ÅÑÊôÇÂàª„ÇíË®àÁÆóÔºà15ÂàÜÂçò‰Ωç„Å´‰∏∏„ÇÅ„ÇãÔºâ
    const hourDecimal = newTop / HOUR_HEIGHT
    const hour = Math.floor(Math.max(0, Math.min(23, hourDecimal)))
    const minute = Math.round(Math.max(0, (hourDecimal - hour) * 60 / 15)) * 15

    // Êñ∞„Åó„ÅÑÈñãÂßãÊôÇÂàª„Çí‰ΩúÊàê
    const newStartTime = new Date(date)
    newStartTime.setHours(hour, minute, 0, 0)

    // „Ç§„Éô„É≥„ÉàÊõ¥Êñ∞„ÇíÂÆüË°åÔºàÂÆüÈöõ„Å´„Éâ„É©„ÉÉ„Ç∞„ÅåÁô∫Áîü„Åó„ÅüÂ†¥Âêà„ÅÆ„ÅøÔºâ
    if (onEventUpdate && dragDataRef.current.eventId && dragDataRef.current.hasMoved) {
      // ÂÆüÈöõ„ÅÆ„Ç§„Éô„É≥„Éà„Éá„Éº„Çø„Åã„ÇâÊúüÈñì„ÇíË®àÁÆó
      const event = events.find(e => e.id === dragDataRef.current.eventId)
      let durationMs = 60 * 60 * 1000 // „Éá„Éï„Ç©„É´„Éà1ÊôÇÈñì
      
      if (event?.startDate && event?.endDate) {
        durationMs = event.endDate.getTime() - event.startDate.getTime()
      } else if (dragDataRef.current.eventDuration) {
        durationMs = (dragDataRef.current.eventDuration / HOUR_HEIGHT) * 60 * 60 * 1000
      }
      
      const newEndTime = new Date(newStartTime.getTime() + durationMs)
      
      // ÈùûÂêåÊúü„Åß„Ç§„Éô„É≥„ÉàÊõ¥Êñ∞„ÇíÂÆüË°å
      onEventUpdate(dragDataRef.current.eventId, {
        startTime: newStartTime,
        endTime: newEndTime
      }).then(() => {
        // ToastÈÄöÁü•„ÅÆ„Åø„ÇíË°®Á§∫ÔºàË©≥Á¥∞„É¢„Éº„ÉÄ„É´„ÅØÈñã„Åã„Å™„ÅÑÔºâ
        const event = events.find(e => e.id === dragDataRef.current!.eventId)
        const eventTitle = event?.title || '„Ç§„Éô„É≥„Éà'
        const timeFormat = `${newStartTime.getHours()}:${newStartTime.getMinutes().toString().padStart(2, '0')}`
        
        success('„Ç§„Éô„É≥„Éà„ÇíÁßªÂãï„Åó„Åæ„Åó„Åü', `${eventTitle}„Çí${timeFormat}„Å´ÁßªÂãï„Åó„Åæ„Åó„Åü`)
      }).catch((error) => {
        console.error('Failed to update event time:', error)
      })
    }

    // ÂÆüÈöõ„Å´„Éâ„É©„ÉÉ„Ç∞„ÅåÁô∫Áîü„Åó„ÅüÂ†¥Âêà„ÅÆ„ÅørecentlyDragged„ÇíË®≠ÂÆö
    const actuallyDragged = dragDataRef.current?.hasMoved || false
    
    // „Éâ„É©„ÉÉ„Ç∞Áä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
    setDragState({
      isDragging: false,
      isResizing: false,
      draggedEventId: null,
      dragStartPosition: null,
      currentPosition: null,
      originalPosition: null,
      snappedPosition: null,
      previewTime: null,
      recentlyDragged: actuallyDragged, // ÂÆüÈöõ„Å´„Éâ„É©„ÉÉ„Ç∞„Åó„ÅüÂ†¥Âêà„ÅÆ„Åø„ÇØ„É™„ÉÉ„ÇØÁÑ°ÂäπÂåñ
      recentlyResized: false, // „Éâ„É©„ÉÉ„Ç∞ÁµÇ‰∫ÜÊôÇ„ÅØ„É™„Çµ„Ç§„Ç∫„Éï„É©„Ç∞„Çí„ÇØ„É™„Ç¢
      ghostElement: null
    })
    dragDataRef.current = null

    // ÂÆüÈöõ„Å´„Éâ„É©„ÉÉ„Ç∞„ÅåÁô∫Áîü„Åó„ÅüÂ†¥Âêà„ÅÆ„Åø„ÄÅ500msÂæå„Å´recentlyDragged„ÇíËß£Èô§
    if (actuallyDragged) {
      setTimeout(() => {
        setDragState(prev => ({ ...prev, recentlyDragged: false }))
      }, 500)
    }
  }, [dragState, onEventUpdate, date])

  // „Ç§„Éô„É≥„Éà„Éâ„É≠„ÉÉ„Éó„ÅÆ„Éò„É´„Éë„Éº
  const handleEventDrop = useCallback((eventId: string, newStartTime: Date) => {
    if (onEventUpdate) {
      // „Ç§„Éô„É≥„Éà„ÅÆÂÖÉ„ÅÆÊúüÈñì„ÇíÂèñÂæó„Åó„Å¶Êñ∞„Åó„ÅÑÁµÇ‰∫ÜÊôÇÂàª„ÇíË®àÁÆó
      const event = events.find(e => e.id === eventId)
      let durationMs = 60 * 60 * 1000 // „Éá„Éï„Ç©„É´„Éà1ÊôÇÈñì
      
      if (event?.startDate && event?.endDate) {
        durationMs = event.endDate.getTime() - event.startDate.getTime()
      }
      
      const newEndTime = new Date(newStartTime.getTime() + durationMs)
      onEventUpdate(eventId, { startTime: newStartTime, endTime: newEndTime })
    }
  }, [onEventUpdate, events])

  // „É™„Çµ„Ç§„Ç∫ÈñãÂßã
  const handleResizeStart = useCallback((
    eventId: string,
    direction: 'top' | 'bottom',
    e: React.MouseEvent,
    originalPosition: { top: number; left: number; width: number; height: number }
  ) => {
    // Â∑¶„ÇØ„É™„ÉÉ„ÇØ‰ª•Â§ñ„ÅØÁÑ°Ë¶ñ
    if (e.button !== 0) return
    
    console.log('üü° „É™„Çµ„Ç§„Ç∫ÈñãÂßã:', { eventId, direction, originalPosition })
    
    const startPosition = { x: e.clientX, y: e.clientY }
    
    // „Éâ„É©„ÉÉ„Ç∞„Éá„Éº„Çø„ÇíË®≠ÂÆö
    dragDataRef.current = {
      eventId,
      startY: e.clientY,
      originalTop: originalPosition.top,
      eventDuration: originalPosition.height,
      hasMoved: false,
      originalElement: null
    }

    setDragState({
      isDragging: false,
      isResizing: true,
      draggedEventId: eventId,
      dragStartPosition: startPosition,
      currentPosition: startPosition,
      originalPosition,
      snappedPosition: { top: originalPosition.top, height: originalPosition.height },
      previewTime: null,
      recentlyDragged: false,
      ghostElement: null
    })
  }, [])

  return {
    dragState,
    handlers: {
      handleMouseDown,
      handleMouseMove,
      handleMouseUp,
      handleEventDrop,
      handleResizeStart
    }
  }
}